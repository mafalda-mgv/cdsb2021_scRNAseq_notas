# Selecci√≥n de genes

Instructora: [**Yalbi I. Balderas-Mart√≠nez**](http://Yalbibalderas.github.io/)

## Diapositivas de Peter Hickey

Ver las diapositivas originales [aqu√≠](https://docs.google.com/presentation/d/19J2FyjKlBQdAkku4Oa6UZ6SA-Y4P7AEKCRIbEQWA9ho/edit#slide=id.ga100bba375887aa_0)


## Motivaci√≥n

* Usualmente usamos datos scRNA-seq para caracterizar la heterogeneidad entre c√©lulas

* Para hacer esto, usamos m√©todos como el clustering y la reducci√≥n de dimensionalidad

* Esto involucra resumir las diferencias por gen en una sola medida de (dis)similitud entre un par de c√©lulas

* **¬øCu√°les genes deber√≠amos usar para calcular esta medida de (dis)similitud?**



## Selecci√≥n de _features_ (genes)

La elecci√≥n de los _features_ tiene un mayor impacto en qu√© tan similares decidimos que son las c√©lulas 

* ‚ûï _Features_ que contienen informaci√≥n √∫til biol√≥gica 
* ‚ûñ _Features_ que contienen ruido aleatorio
* üëâ Efectos laterales al reducir la dimensionalidad de los datos 

Deseamos seleccionar los **genes altamente variables** (High Variable Genes **HVGs**). Genes con una variaci√≥n incrementada en comparaci√≥n con otros genes que est√°n siendo afectados por ruido t√©cnico u otra variaci√≥n biol√≥gica que no es de nuestro inter√©s.

## Dataset ilustrativo: PBMC4k 10X sin filtrar

### Descargar datos

```{r, warning=FALSE, message=FALSE}
# Usemos datos de pbmc4k
library(BiocFileCache)
bfc <- BiocFileCache()
raw.path <- bfcrpath(bfc, file.path(
    "http://cf.10xgenomics.com/samples",
    "cell-exp/2.1.0/pbmc4k/pbmc4k_raw_gene_bc_matrices.tar.gz"
))
untar(raw.path, exdir = file.path(tempdir(), "pbmc4k"))

library(DropletUtils)
library(Matrix)
fname <- file.path(tempdir(), "pbmc4k/raw_gene_bc_matrices/GRCh38")
sce.pbmc <- read10xCounts(fname, col.names = TRUE)
sce.pbmc
```

Dataset "C√©lulas mononucleares humanas de sangre perif√©rica" de 10X Genomics

Descripci√≥n [aqu√≠](https://osca.bioconductor.org/unfiltered-human-pbmcs-10x-genomics.html) ^[Zheng, G. X. Y. et al. Massively parallel digital transcriptional profiling of single cells. Nat. Commun. 8, 14049 (2017).]

### Anotaci√≥n

```{r, warning=FALSE, message=FALSE}
# Anotaci√≥n de los genes
library(scater)
rownames(sce.pbmc) <- uniquifyFeatureNames(
    rowData(sce.pbmc)$ID, rowData(sce.pbmc)$Symbol
)
library(EnsDb.Hsapiens.v86)
location <- mapIds(EnsDb.Hsapiens.v86,
    keys = rowData(sce.pbmc)$ID,
    column = "SEQNAME", keytype = "GENEID"
)

# Detecci√≥n de _droplets_ con c√©lulas
set.seed(100)
e.out <- emptyDrops(counts(sce.pbmc))
sce.pbmc <- sce.pbmc[, which(e.out$FDR <= 0.001)]
```

### Control de calidad

```{r, warning=FALSE, message=FALSE}
# Control de calidad
stats <- perCellQCMetrics(sce.pbmc,
    subsets = list(Mito = which(location == "MT"))
)
high.mito <- isOutlier(stats$subsets_Mito_percent,
    type = "higher"
)
sce.pbmc <- sce.pbmc[, !high.mito]

# Normalizaci√≥n de los datos
library(scran)
set.seed(1000)
clusters <- quickCluster(sce.pbmc)
sce.pbmc <- computeSumFactors(sce.pbmc, cluster = clusters)
sce.pbmc <- logNormCounts(sce.pbmc)
```

### Preguntas de repaso

* ¬øC√≥mo determinamos cuales eran los genes mitocondriales? ^[Usando Ensembl v86 para humano]
* ¬øC√≥mo decidimos filtrar las c√©lulas? ^[Usamos los resultados de `emptyDrops()` con un l√≠mite de 0.1% FDR y el filtro de 3 desviaciones sobre la mediana (MAD) en la expresi√≥n mitocondrial.]
* ¬øPuedes explicar como normalizamos los datos? ^[Encontramos unos clusters r√°pidos para las c√©lulasy usamos esa informaci√≥n para calcular los factores de tama√±o.]

## Cuantificando la varianza por gen


### Varianza de los _log-counts_

El enfoque m√°s simple para cuantificar la variaci√≥n _per-feature_ es simplemente calcular la varianza de los _log-counts_

* ‚ûï Selecci√≥n del _feature_  basado en los _log-counts_ (que ser√°n usadas en los an√°lisis m√°s adelante)
* ‚ö†Ô∏è La transformaci√≥n log no logra la estabilizaci√≥n de la varianza perfecta, as√≠ que se requiere modelar la relaci√≥n de la varianza-media de los _features_.


### Enfoque simple

1. Calcular la varianza de los _log-counts_ para cada gen (ignorando grupos experimentales)
2. Ordenar los genes del m√°s-al-menos variable

### Un enfoque m√°s sofisticado

1. Calcular la varianza de los _log-counts_ para cada gen (ignorando grupos experimentales)
2. Modelar la relaci√≥n de la media de la varianza de los _log-counts_ para estimar la variaci√≥n _t√©cnica_
3. Estimar la varianza _biol√≥gica_ sustrayendo la varianza _t√©cnica_ de la varianza total
4. Ordenar los genes de la variable de mayor-a-menor biol√≥gicamente


### Supuestos

````{r, warning=FALSE, message=FALSE}
# Varianza de las log-counts
library(scran)
dec.pbmc <- modelGeneVar(sce.pbmc)
```

* ü§ì El supuesto es que a cualquier abundancia dada, la abundancia de los perfiles de expresi√≥n de la mayor√≠a de los genes est√°n dominados por el ruido aleatorio _t√©cnico_
* ü§ì Por lo consiguiente, una tendencia representa un estimado del ruido t√©cnico como una funci√≥n de la abundancia
* ü§ì Podemos entonces descomponer la varianza total de cada gen en un componente _t√©cnico_ y uno _biol√≥gico_ 
* ü§ì Genes con una gran varianza _biol√≥gica_ son considerados interesantes 

### Visualizando la media y varianza

```{r, warning=FALSE, message=FALSE}
# Visualicemos la relaci√≥n entre la media y la varianza
fit.pbmc <- metadata(dec.pbmc)
plot(fit.pbmc$mean, fit.pbmc$var,
    xlab = "Mean of log-expression",
    ylab = "Variance of log-expression"
)
curve(fit.pbmc$trend(x), col = "dodgerblue", add = TRUE, lwd = 2)
```

#### Ejercicios

* ¬øQu√© tipo de objeto nos regres√≥ `modelGeneVar()`? ^[Es un `DFrame`]
* ¬ø`dec.pbmc` es una tabla? ¬øO contiene mayor informaci√≥n? ^[No, contiene m√°s informaci√≥n dentro de `metadata(dec.pbmc)`]
* ¬øQu√© tipo de objeto es `fit.pbmc` y que objetos con nombres contiene? ^[`class(metadata(dec.pbmc))` y `sapply(metadata(dec.pbmc), class)`]
* ¬øQu√© tipo de objeto es `fit.pbmc$trend`? ^[Una funci√≥n]
* ¬øDonde podemos encontrar m√°s detalles de esta funci√≥n? ^[Checa `?fitTrendVar` y si quieres tambi√©n checa el c√≥digo fuente (para m√≠ es muy √∫til este paso) https://github.com/MarioniLab/scran/blob/master/R/fitTrendVar.R]


### Ordenando genes interesantes

```{r, warning=FALSE, message=FALSE}
# Ordenemos por los genes m√°s interesantes para checar
# los datos
dec.pbmc[order(dec.pbmc$bio, decreasing = TRUE), ]
```



## Coeficiente de variaci√≥n de las cuentas

El coeficiente de variaci√≥n de las cuentas al cuadrado (CV<sup>2</sup>) es una alternativa a la varianza de los _log-counts_

* üëâ Se calcula usando las cuentas en lugar de los _log-counts_

* ü§ì CV es la tasa de la desviaci√≥n est√°ndar a la media y est√° muy relacionada con el par√°metro de _dispersi√≥n_ de la distribuci√≥n binomial negativa usada en edgeR y DESeq2



### Coeficiente de variaci√≥n

```{r, warning=FALSE, message=FALSE}
# Coeficiente de variaci√≥n
dec.cv2.pbmc <- modelGeneCV2(sce.pbmc)
```

* ü§ì Modela la relaci√≥n de la media de la varianza cuando se considera la relevancia de cada gen
* ü§ì Asume que la mayor√≠a de los genes contienen ruido aleatorio y que la tendencia captura la mayor√≠a de la variaci√≥n t√©cnica 
* ü§ì Genes con un gran CV<sup>2</sup> que se desv√≠an fuertemente de la tendencia es probable que representen genes afectados por la estructura biol√≥gica 
* ü§ì Usa la tasa (en lugar de la diferencia) del CV<sup>2</sup> a la tendencia



### Visualizando el coeficiente de variaci√≥n

```{r, warning=FALSE, message=FALSE, echo = FALSE}
# Visualicemos la relaci√≥n con la media
fit.cv2.pbmc <- metadata(dec.cv2.pbmc)
plot(fit.cv2.pbmc$mean, fit.cv2.pbmc$cv2,
    log = "xy"
)
curve(fit.cv2.pbmc$trend(x),
    col = "dodgerblue",
    add = TRUE, lwd = 2
)
```



### Genes por coeficiente de variaci√≥n

```{r, warning=FALSE, message=FALSE}
# Ordenemos por los genes m√°s interesantes para checar
# los datos
dec.cv2.pbmc[order(dec.cv2.pbmc$ratio,
    decreasing = TRUE
), ]
```

## Varianza de los _log-counts_ vs coeficiente de variaci√≥n

**Generalmente se usa la varianza de los _log-counts_** 

* Ambas son medidas efectivas para cuantificar la variaci√≥n en la expresi√≥n g√©nica 
* CV<sup>2</sup> tiende a tener otorgar rangos altos en abundancias bajas de genes altamente variables 
	- √âstos son dirigidos por una sobreregulaci√≥n en subpoblaciones raras 
  - Puede asignar un alto rango a genes que no son de nuestro inter√©s con varianza baja absoluta	
* La variaci√≥n descrita por el CV<sup>2</sup> de las cuentas es menos relevante para los procedimientos que operan en los _log-counts_

## Detalles de la sesi√≥n de R

```{r}
## Informaci√≥n de la sesi√≥n de R
Sys.time()
proc.time()
options(width = 120)
sessioninfo::session_info()
```

## Patrocinadores {-}

Agradecemos a nuestros patrocinadores:

<a href="https://comunidadbioinfo.github.io/es/post/cs_and_s_event_fund_award/#.YJH-wbVKj8A"><img src="https://comunidadbioinfo.github.io/post/2021-01-27-cs_and_s_event_fund_award/spanish_cs_and_s_award.jpeg" width="400px" align="center"/></a>

<a href="https://www.r-consortium.org/"><img src="https://www.r-consortium.org/wp-content/uploads/sites/13/2016/09/RConsortium_Horizontal_Pantone.png" width="400px" align="center"/></a>
